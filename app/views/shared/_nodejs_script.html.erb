// this script must be run via sudo for the i2c communication to work
// example: sudo nodejs limitos.js

// variable for the device ID
var device_id = '<%= @device.id %>';
// variable for the auth_token
var auth_token = '<%= @device.auth_token %>';
// variable for the slave i2c addresses
var slave_i2c_addresses = [];

// set up the websocket object
const WebSocket = require('ws');
// set up the rpio object
var rpio = require('rpio');

// keep track of the last position
var last_position = '';

// variable for the websocket, with the websocket server URL
const ws = new WebSocket('<%= @websocket_server_url %>');

// enable i2c
rpio.init({gpiomem: false});

// use Broadcom GPIO pin naming
rpio.init({mapping: 'gpio'});

// create the channel JSON
var channel_json = JSON.stringify({
  channel: 'DevicesChannel',
  id: device_id,
  auth_token: auth_token
});

// when the websocket client connects to the server
ws.on('open', function() {
  // create the device subscription
  var device_subscription = {
    command: 'subscribe',
    identifier: channel_json
  };

  // send the subscription command
  ws.send(JSON.stringify(device_subscription));
});

// when the websocket receives a message
ws.on('message', function(data, flags) {
  // get the JSON data
  var json_data = JSON.parse(data);

  // if this is a ping command
  if (json_data.type === 'ping') {
    // log the ping message
    //console.log('ping: ' + json_data.message);
  // else if this is a subscription confirmation
  } else if (json_data.type === 'confirm_subscription') {
    console.log('subscribed to: ' + json_data.identifier);
    // after subscription confirmation, send request for i2c addresses
    requestI2CAddresses();
  // else if this is a device message, handle it
  } else if (json_data.identifier === channel_json) {
    handleDeviceMessage(json_data.message);
  // else log the full message
  } else {
    console.log('message received: ' + data);
  }

});

// send a request to get the i2c slave addresses
function requestI2CAddresses() {
  // create the command to send
  var input = {
    command: 'message',
    identifier: channel_json,
    data: JSON.stringify({ action: 'request_i2c_addresses' })
  }
  // send the message
  ws.send(JSON.stringify(input));
}

// handle a device message
function handleDeviceMessage(message) {
  // if this is an i2c command
  if (message.i2c_address) {
    handleI2cMessage(message);
  // else if this is a message with the slave i2c addresses
  } else if (message.i2c_addresses) {
    // set the addresses
    slave_i2c_addresses = message.i2c_addresses;
    // for each address
    slave_i2c_addresses.forEach(function(i2c_address) {
      console.log('slave address: ' + parseInt(i2c_address, 16));
    });
  // else this is a direct message for the raspberry pi
  } else {
    handleDirectMessage(message);
  }
}

// handle a direct message to the raspberry pi
function handleDirectMessage(message) {
  // initialize variables
  var pin_state;
  var pin_number = parseInt(message.pin);

  // if this is an on message
  if (message.digital === 'on') {
    pin_state = rpio.HIGH;
  // else if this is an off message
  } else if (message.digital === 'off') {
    pin_state = rpio.LOW;
  }

  // if this is a digital message
  if (message.digital && message.digital.length !== 0) {
    // output the message to the correct pin
    rpio.open(pin_number, rpio.OUTPUT, pin_state);
  }
}

// handle an i2c message
function handleI2cMessage(message) {
  // calculate the delay
  var start_time = (new Date).getTime();
  var delay = start_time - message.time;
  var i2c_delay, log_message;

  // begin using i2c
  rpio.i2cBegin();
  // set i2c address (parsed in hex)
  rpio.i2cSetSlaveAddress(parseInt(message.i2c_address, 16));
  // set baudrate
  rpio.i2cSetBaudRate(9600);

  // if there is a digital output command
  if (message.digital && message.digital.length !== 0) {
    // send the digital command
    rpio.i2cWrite(new Buffer("pin:" + message.pin + ",digital:" + message.digital));
    log_message = "digital_" + message.digital + ",pin_" + message.pin;
  // if there is a servo command
  } else if (message.servo && message.servo.length !== 0) {
    // send the servo command
    rpio.i2cWrite(new Buffer("pin:" + message.pin + ",servo:" + message.servo));
    log_message = "servo_" + message.servo + ",pin_" + message.pin;
  }

  // end i2c
  rpio.i2cEnd();

  // set the i2c delay
  i2c_delay = (new Date).getTime() - start_time;
  console.log(log_message + ', ws delay: ' + delay + 'ms, i2c delay: ' + i2c_delay + 'ms');

}

// request i2c data
function requestI2CData(i2c_address) {
  rpio.i2cBegin();
  rpio.i2cSetSlaveAddress(parseInt(i2c_address, 16));
  // set baudrate high for faster polling speed
  rpio.i2cSetBaudRate(100000);
  // buffer with max message length of 32 characters
  var receive_buffer = new Buffer(32);
  rpio.i2cRead(receive_buffer);
  rpio.i2cEnd();
  // convert the buffer to a string
  var message = receive_buffer.toString();
  // only get the relevant portion of the message
  var current_position = message.substring(message.indexOf('position') + 10, message.indexOf('end') - 1);

  // if the last_position is more than 1 degree different than the current position
  if (last_position > (current_position + 1) || last_position < (current_position - 1)) {
    console.log(current_position);
    last_position = current_position;
    sendWebsocketCommand(i2c_address, current_position);
  }
}

// send websocket command with the correct position
function sendWebsocketCommand(i2c_address, position) {
  // exit if websocket isn't ready
  if (ws.readyState === 0) { return }

  // create the command to send
  var input = {
    command: 'message',
    identifier: channel_json,
    data: JSON.stringify({
      i2c_address: i2c_address,
      pin: '3',
      servo: position
    })
  }

  // send the websocket input
  ws.send(JSON.stringify(input));
}

// continually request i2c data
//setInterval(function() { requestI2CData(); }, 1);
